---
title: "Data Visualization in R with ggplot2"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

## Quick Intro to R Notebooks and R Markdown

This is an R Markdown Notebook. When you execute code within the notebook, the results appear beneath the code. 

This file was created by going to File...New File...R Notebook.

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter* (Win/Linux) or *Cmd+Shift+Return* (Mac). 

```{r}
summary(cars$speed)
hist(cars$speed)
```

To hide the output, click the Expand/Collapse output button. To clear results, click the "x". 

You can also press *Ctrl+Enter* (Win/Linux) or *Cmd+Return* (Mac) to run one line of code at a time (instead of the entire chunk).

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I* (Win/Linux) or *Cmd+Option+I* (Mac).  


## Import data

Let's import some data which we'll visualize today. The data we'll work with is Albemarle County real estate data which was downloaded from the Office of Geographic Data Services. We'll use a random sample of the data.

```{r}
URL <- 'https://raw.githubusercontent.com/clayford/dataviz_with_ggplot2/master/alb_homes.csv'
homes <- read.csv(file = URL)
```

Let's look at the first few rows:

```{r}
head(homes)
```

Variable name definitions:

- *yearbuilt*: year house was built
- *finsqft*: size of house in number square feet
- *cooling*: 'Central Air' versus 'No Central Air'
- *bedroom*: number of bedrooms
- *fullbath*: number of full bathrooms (toilet, sink and bath)
- *halfbath*: number of half bathrooms (toilet and sink only)
- *lotsize*: size of land on which home is located, in acres
- *totalvalue*: total assessed value of home and property
- *esdistrict*: the elementary school the home feeds into
- *msdistrict*: the middle school the home feeds into
- *hsdistrict*: the high school the home feeds into
- *censustract*: the census tract the home is located in
- *age*: of the house in years as of 2018
- *condition*: assessed condition of home (Substandard, Poor, Fair, Average, Good, Excellent)
- *fp*: indicator if house has fireplace (0=no, 1=yes)


## Intro to ggplot2

The ggplot2 package implements *The Grammar of Graphics* as defined in the book of the same name by Leland Wilkinson.

It requires your data be in a data frame or tibble.

The basic idea:
- use `ggplot` function to create a plotting area for a data frame
- use `aes` function to map variables in data frame to aesthetic properties of geometric shapes
- use`geom_` functions to specify the geometric shapes
- combine these functions with `+`

An example will hopefully make this clear.

Plot totalvalue versus finsqft to create a scatter plot. How does the total value of a home relate to its size in finished square feet?

First we need to load the ggplot2 package. Only do this once per R session

```{r}
# install.packages('ggplot2')
library(ggplot2)
ggplot(homes) +
  aes(x = finsqft, y = totalvalue) +
  geom_point()
```

Don't forget the parentheses on `geom_point()`! 

We can also nest the `aes` function in the `ggplot` function:

```{r}
ggplot(homes, aes(x = finsqft, y = totalvalue)) +
  geom_point()
```

This says "create a plot with points in a plane, where the x attribute of the points is mapped to finsqft and the y attribute of the points is mapped to totalvalue."

## Exercise 1

Create a scatterplot of finsqft (y-axis ) versus age (x-axis). Are younger (more recently built houses) bigger than older homes? Reminder: Insert a new code chunk by pressing *Ctrl+Alt+I* (Win/Linux) or *Cmd+Option+I* (Mac).  

```{r}
ggplot(homes, aes(x = age, y = finsqft)) + 
  geom_point()

```


## More aesthetics

Points not only have positions in a plane, but can be different sizes and have different shapes and colors. We can map variables in our data frame to these aesthetics. 

Plot totalvalue versus finsqft to create a scatter plot, but also color the points according to whether or not the homes have central air (cooling)

```{r}
ggplot(homes) +
  aes(x = finsqft, y = totalvalue, color = cooling) +
  geom_point()
```

We can also map the size of the points to a variable, such as lotsize.

```{r}
ggplot(homes) +
  aes(x = finsqft, y = totalvalue, shape = cooling, size = lotsize) +
  geom_point()

```

Perhaps we prefer to see separate scatterplots for each cooling category. We can achieve that with *facets*. The function to use is `facet_wrap()` with the variable that we want to facet on. In this case it's cooling. Notice we precede the variable with a tilde ~. We can read that as "facet by cooling"  

```{r}
ggplot(homes) +
  aes(x = finsqft, y = totalvalue, size = lotsize) +
  geom_point() +
  facet_wrap(~ cooling)

```

We can also have multiple geoms in a plot. Let's say we want to add a smooth trend line that summarizes the relationship between finsqft and totalvalue:

```{r}
ggplot(homes) +
  aes(x = finsqft, y = totalvalue) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~ cooling)

```

## Exercise 2

Create a scatterplot of totalvalue (y-axis) vs lotsize (x-axis), faceted by hsdistrict. Add smooth trend lines to summarize the relationship.

```{r}
ggplot(homes) +
  aes(x = lotsize, y = totalvalue) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~ hsdistrict)
```


## Zooming in and transforming data

The totalvalue and lotsize variables are very skewed. That is, some values are an order of magnitude larger than the rest of the values. For example, a 5 million dollar home is one order of magnitude larger than a $500,000 home. Displaying the larger values forces the smaller values into clumps. 

Two common approaches to visualizing skewed data: 
1. zoom in on the data
2. transform the data (for example, with a log transformation)

### Zooming in on data

To zoom in on data with ggplot2, we use the `coord_cartesion()` function and define the limits to view with the xlim and ylim arguments. Below we zoom in on the y-axis only.

```{r}
ggplot(homes) +
  aes(x = finsqft, y = totalvalue) +
  geom_point() +
  geom_smooth() +
  coord_cartesian(ylim = c(0, 1e6)) # from 0 to $1,000,000
```

### Transforming data

Another approach is to transform the data. An easy transformation is a log10 transformation. With a log10 transformation, 1,000,000 becomes 6 and and 100,000 becomes 5. This has the effect of bringing the big values closer to the smaller values, and spreading out the clumps of smaller values. 

With ggplot, we can use the `scale_y_log10()` and/or `scale_x_log10()` to transform the data. Below we transform the y-axis. Notice the y-axis is still labeled in dollars, but the plot is displaying log10-transformed values.

```{r}
ggplot(homes) +
  aes(x = finsqft, y = totalvalue) +
  geom_point() +
  geom_smooth() +
  scale_y_log10()
```

The numbers are a little hard to read on the y-axis. We can format them as dollar amounts using the labels argument in the `scale_y_log10()` function. To do this we need to load the scales package

```{r}
library(scales) # for the dollar function
ggplot(homes) +
  aes(x = finsqft, y = totalvalue) +
  geom_point() +
  geom_smooth() +
  scale_y_log10(labels=dollar) 

```

The larger values are now "closer" to the smaller values, but the relationship appears less dramatic.


## Exercise 3

Modify your code from Exercise 2 to log10 transform the data on the y axis and zoom in on the x-axis to view homes on lots size 0 to 10 acres. 

```{r}
ggplot(homes) +
  aes(x = lotsize, y = totalvalue) +
  geom_point() +
  geom_smooth() +
  scale_y_log10(label=dollar) +
  coord_cartesian(xlim = c(0,10)) +
  facet_wrap(~ hsdistrict)

```

## Visualizing counts

Recall the condition variable. We can quickly get counts of each condition using the table function:

```{r}
table(homes$condition)
```

One way to visualize counts is with a bar plot. We can create a bar plot in ggplot2 with `geom_bar()`. Notice it automatically generates the counts for us.

```{r}
ggplot(homes) +
  aes(x = condition) +
  geom_bar()
```

If we want the x-axis ordered according to condition, it's best to define that ordering in the data frame. We can use the `factor` function to achieve this.

```{r}
homes$condition <- factor(homes$condition, 
                          levels = c('Substandard', 'Poor', 'Fair', 
                                     'Average', 'Good', 'Excellent'))
```

Now when we generate the bar plot, the x-axis in the order as defined in the data frame.

```{r}
ggplot(homes) +
  aes(x = condition) +
  geom_bar()
```

One of the aesthetics of bars is their fill color. We can map a variable from our data frame to the fill aesthetic. For example, let's see counts of conditions for homes with and without central air (cooling).

```{r}
ggplot(homes) +
  aes(x = condition, fill = cooling) +
  geom_bar()

```

The default result is to stack the bars. We can set them side-by-side setting the position argument to "dodge".

```{r}
ggplot(homes) +
  aes(x = condition, fill = cooling) +
  geom_bar(position = "dodge")

```


The large number of Average homes makes it difficult to see the counts for the other categories. An alternative approach is to view the proportion of homes with and without central air within each condition. We can do this by setting the position argument to "fill".

```{r}
ggplot(homes) +
  aes(x = condition, fill = cooling) +
  geom_bar(position = "fill")

```

